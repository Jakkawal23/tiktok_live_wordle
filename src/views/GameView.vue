<template>
  <main class="flex flex-col h-full">
    <!-- ‡∏™‡πà‡∏ß‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö -->
    <div class="flex-1 flex flex-col items-center">
      <span class="flex gap-4 my-2">
        <span>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà {{ dateIndex + 1 }}</span>
        <span>‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà {{ attemptsLength }}/{{ attemptLimit }}</span>
      </span>

      <div class="attempts flex flex-col items-center gap-2">
        <!-- ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡∏•‡∏≠‡∏á -->
        <div v-for="(inputWord, n) in attempts" :key="n" class="flex justify-center my-1">
          <div
            v-for="({ correct, char }, idx) in validations[n] || []"
            :key="idx"
            :class="[
              colors[correct] || 'bg-background',
              'attempt-key flex items-center justify-center mx-1 text-3xl font-bold text-white',
            ]"
          >
            {{ char ?? "" }}
          </div>
        </div>

        <!-- ‡∏ä‡πà‡∏≠‡∏á input ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå -->
        <div v-if="!gameEnded" class="flex justify-center my-1">
          <div
            v-for="(_, i) in solutionLength"
            :key="i"
            class="attempt-key flex items-center justify-center mx-1 text-3xl font-bold bg-card text-text"
          >
            {{ splittedInput[i] || "" }}
          </div>
        </div>

        <!-- ‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠ (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏î‡∏≤) -->
        <div
          v-for="(_, n) in Array(Math.max(0, attemptLimit - attempts.length - 1))"
          :key="n"
          class="flex justify-center my-1"
        >
          <div
            v-for="_ in Array(solutionLength).fill(0)"
            :key="_"
            class="attempt-key flex items-center justify-center mx-1 text-3xl font-bold bg-card text-text"
          />
        </div>
      </div>
    </div>

    <!-- ‡∏Ñ‡∏µ‡∏¢‡πå‡∏ö‡∏≠‡∏£‡πå‡∏î -->
    <div class="border-t border-border">
      <div class="layout w-full px-1 max-w-4xl mx-auto">
        <input
          ref="textInput"
          type="text"
          class="w-full sm:w-[500px] block mb-5 px-5 py-4 mx-auto text-center bg-card text-input placeholder:text-input"
          @keydown="handleKeyPress"
          @blur="focusOnTextInput = false"
          @focus="focusOnTextInput = true"
          v-model="input"
          :disabled="gameEnded"
          placeholder="‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏Ñ‡∏µ‡∏¢‡πå‡∏ö‡∏≠‡∏£‡πå‡∏î"
        />

        <div
          v-for="(row, rowIndex) in currentRows"
          :key="rowIndex"
          class="w-full flex flex-row justify-center touch-manipulation"
        >
          <div
            v-for="(alphabet, alphabetIndex) in row"
            :key="alphabetIndex"
            class="flex-grow flex m-0.5 relative"
          >
            <button
              @click="inputKey(alphabet)"
              :class="[
                colors[alphabetStateMap[alphabet]],
                ['‚áß', '‚Üµ', '‚¨Ö'].includes(alphabet) ? 'border-gray-500' : '',
                'flex-grow layout-key border-solid border-2 flex items-end justify-end text-xl font-bold rounded text-black h-10 md:h-12 lg:h-14',
              ]"
            >
              {{ alphabet }}
              <div
                v-if="
                  currentRows[rowIndex][alphabetIndex] !==
                  inverseRows[rowIndex][alphabetIndex]
                "
                :class="[
                  colors[alphabetStateMap[inverseRows[rowIndex][alphabetIndex]]],
                  'absolute top-1 left-1 border-solid border-1 rounded text-sm leading-4 p-0.5 w-4',
                ]"
              >
                {{ inverseRows[rowIndex][alphabetIndex] }}
              </div>
            </button>
          </div>
        </div>
      </div>
    </div>
  </main>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, watch } from "vue";
import {
  CharState,
  generateAlphabetStateMap,
  getShareResults,
  splitWord,
  validateWord,
} from "../shared/Wordle";
import { data, modalViewed, settings } from "../shared/Store";
import { layouts } from "../shared/Layouts";

// -------------------------
// üîπ ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏´‡∏•‡∏±‡∏Å
// -------------------------
const url = "https://thwordle.vercel.app";
const title = "Thwordle : Thai Wordle ‡πÄ‡∏ß‡∏≠‡πÄ‡∏î‡∏¥‡πâ‡∏•‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢";
const description = "Thwordle : ‡πÄ‡∏ß‡∏≠‡πÄ‡∏î‡∏¥‡πâ‡∏•‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢";
const imageUrl =
  "https://raw.githubusercontent.com/narze/timelapse/master/projects/thwordle_home.png";
const gtagId = "G-F2Q37REQE6";

const epochMs = 1642525200000;
const now = Date.now();
const msInDay = 86400000;
const dateIndex = Math.floor((now - epochMs) / msInDay);
const attemptLimit = 6;

// -------------------------
// üîπ State
// -------------------------
const words = ref<string[]>([]);
const input = ref("");
const attempts = ref<string[]>(data.value[dateIndex]?.attempts || []);
const validations = ref<any[]>([]);
const gameEnded = ref(!!data.value[dateIndex]?.win || !!data.value[dateIndex]?.lose);
const copied = ref(false);
const lose = ref(false);
const win = ref(false);
const shifted = ref(false);
const alertMessage = ref("");
const showAlert = ref(false);
const focusOnTextInput = ref(false);
const dict = ref<string[]>([]);
const attemptsContainer = ref<HTMLDivElement | null>(null);
const textInput = ref<HTMLInputElement | null>(null);

// -------------------------
// üîπ Colors
// -------------------------
const colors: Record<CharState, string> = {
  [CharState.Correct]: "bg-green-500",
  [CharState.OutOfPlace]: "bg-yellow-500",
  [CharState.Wrong]: "bg-gray-500",
  [CharState.NotUsed]: "bg-white",
};

// -------------------------
// üîπ Computed
// -------------------------
const attemptsLength = computed(() => attempts.value.length);
const solution = computed(() => {
  if (words.value.length === 0) return "";
  return words.value[dateIndex % words.value.length] || "";
});

const solutionLength = computed(() => splitWord(solution.value).length);

const currentLayout = computed(() => {
  return layouts[settings.value?.layout || "Kedmanee"] || layouts["Kedmanee"];
});
const currentRows = computed(() =>
  shifted.value ? currentLayout.value.rowsShifted : currentLayout.value.rows
);
const inverseRows = computed(() =>
  shifted.value ? currentLayout.value.rows : currentLayout.value.rowsShifted
);

const alphabetStateMap = computed(() =>
  generateAlphabetStateMap(
    [...currentLayout.value.rows, ...currentLayout.value.rowsShifted].flat(),
    validations.value.flat()
  )
);
const splittedInput = computed(() => splitWord(input.value));

// -------------------------
// üîπ Functions
// -------------------------
function inputKey(alphabet: string) {
  if (gameEnded.value) return;

  if (alphabet === "‚áß") {
    shifted.value = !shifted.value;
  } else if (alphabet === "‚¨Ö") {
    input.value = input.value.slice(0, -1);
  } else if (alphabet === "‚Üµ" || alphabet === "Enter") {
    submit();
  } else {
    // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≥‡πÅ‡∏•‡∏∞‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß
    if (splittedInput.value.length < solutionLength.value) {
      input.value += alphabet;
      shifted.value = false;
    }
  }
  focusInput();
}

function handleKeyPress(e: KeyboardEvent) {
  if (gameEnded.value) return;
  if (e.key === "Enter") {
    e.preventDefault(); // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ã‡πâ‡∏≥
    submit();
  } else if (e.key === "Backspace") {
    e.preventDefault();
    inputKey("‚¨Ö");
  } else if (e.key.length === 1) {
    e.preventDefault();
    if (splittedInput.value.length < solutionLength.value) {
      inputKey(e.key);
    }
  }
}

function submit() {
  if (splittedInput.value.length !== solutionLength.value) {
    showAlertMessage("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡∏≥‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö");
    return;
  }

  attempts.value.push(input.value);
  validations.value.push(validateWord(input.value, solution.value));
  input.value = "";

  if (attemptsContainer.value) {
    attemptsContainer.value.scrollTop = attemptsContainer.value.scrollHeight;
  }

  // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏Å‡∏°‡∏à‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  if (input.value === solution.value) {
    gameEnded.value = true;
    win.value = true;
  } else if (attempts.value.length >= attemptLimit) {
    gameEnded.value = true;
    lose.value = true;
  }

  // ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÉ‡∏ô console ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡∏°‡∏à‡∏ö
  // if (gameEnded.value) {
  console.log("‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏∑‡∏≠:", solution.value);
  // }
}

function wordExists(word: string) {
  return words.value.includes(word) || dict.value.includes(word);
}

function showAlertMessage(msg: string) {
  alertMessage.value = msg;
  showAlert.value = true;
}

function copyResult() {
  const results = getShareResults(validations.value);
  const score = (lose.value ? "X" : `${results.length}`) + `/${attemptLimit}`;
  navigator.clipboard.writeText(
    `#Thwordle ${dateIndex + 1} ${score}\n\n${results.join("\n")}`
  );
  copied.value = true;
  setTimeout(() => (copied.value = false), 2000);
}

function focusInput() {
  textInput.value?.focus();
}

// -------------------------
// üîπ Load Data
// -------------------------
onMounted(async () => {
  try {
    const res = await fetch("/words.json");
    if (!res.ok) throw new Error("Cannot load words.json");
    const json = await res.json();
    words.value = json.words || [];
    dict.value = (await import("../assets/dict.json")).default;

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á validations ‡∏à‡∏≤‡∏Å attempt ‡πÄ‡∏î‡∏¥‡∏°
    validations.value = attempts.value.map((attempt) =>
      validateWord(attempt, solution.value)
    );
  } catch (err) {
    console.error("Error loading words.json:", err);
  }
});
</script>

<style>
.attempt-key {
  width: 3rem;
  height: 3rem;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}

.attempts {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

.layout {
  margin-top: 1rem;
}
</style>
